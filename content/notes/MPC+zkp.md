### 6.5 Zero-Knowledge Proofs
An alternative to the cut-and-choose approach is to convert a semi-honest protocol into a malicious-secure protocol by incorporating a proof that the protocol was executed correctly. Of course, the proof cannot reveal the secrets used in the protocol. Goldreich et al. (1987) shows how to use zero-knowledge (ZK) proofs to turn any semi-honest MPC protocol into one that is secure against malicious adversaries (Section 6.5.1).

Zero-knowledge proofs are a special case of malicious secure computation, and were introduced in Section 2.4. ZK proofs allow a prover to convince a verifier that it knows x such that C(x) = 1, without revealing any additional information about x, where C is a public circuit.

#### 6.5.1 GMW Compiler
Goldreich, Micali, and Wigderson (GMW) showed a compiler for secure multiparty computation protocols that uses ZK proofs (Goldreich et al., 1987). The compiler takes as input any protocol secure against semi-honest adversaries, and generates a new protocol for the same functionality that is secure against malicious adversaries.

Let π denote the semi-honest-secure protocol. The main idea of the GMW compiler is to run π and prove in zero-knowledge that every message is the result of running π honestly. The honest parties abort if any party fails to provide a valid ZK proof. Intuitively, the ZK proof ensures that a malicious party can either run π honestly, or cheat in π but cause the ZK proof to fail. If π is indeed executed honestly, then the semi-honest security of π ensures security. Whether or not a particular message is consistent with honest execution of π depends on the parties’ private inputs. Hence, the ZK property of the proofs ensures that this property can be checked without leaking any information about these private inputs.


Construction. The main challenge in transforming a semi-honest protocol into an analogous malicious-secure protocol is to precisely define the circuit that characterizes the ZK proofs. Two important considerations are: 
1. Each party must prove that each message of π is consistent with honest execution of π, on a consistent input. In other words, the ZK proof should prevent parties from running π with different inputs in different rounds.
2. The “correct” next message of π is a function of not only the party’s private input, but also their private random tape. π guarantees security only when each party’s random tape is chosen uniformly. In particular, the protocol may be insecure if the party runs honestly but on some adversarially-chosen random tape.

The first consideration is addressed by having each party commit to its input upfront. Then all ZK proofs refer to this commitment: e.g., the following message is consistent with an honest execution of π, on the input that is contained inside the public commitment.

The second consideration is addressed by a technique called coin-tossing into the well. For concreteness, we focus on the ZK proofs generated by P1. Initially P1 produces a commitment to a random string r. Then P2 sends a value r 0 in the clear. Now P1 must run π with r ⊕ r 0 as the random tape. In this way, P1 does not have unilateral control over its effective random tape r ⊕ r 0 — it is distributed uniformly even if P1 is corrupt. P1’s ZK proofs can refer to the commitment to r (and the public value r 0 ) to guarantee that π is executed with r ⊕ r 0 as its random tape.

The full protocol description is given in Figure 6.1.

#### 6.5.2 ZK from Garbled Circuits
Jawurek, Kerschbaum, and Orlandi (JKO) presented an elegant zero-knowledge protocol based on garbled circuits (Jawurek et al., 2013). Since zero-knowledge is a special case of malicious secure computation, one can obviously base zero-knowledge on any cut-and-choose-based 2PC protocol. However, these protocols require many garbled circuits. The JKO protocol on the other hand achieves zero-knowledge using only one garbled circuit.

The main idea is to use a single garbled circuit for both evaluation and checking. In standard cut-and-choose, opening a circuit that is used for evaluation would reveal the private input of the garbled circuit generator. However, the verifier in a zero-knowledge protocol has no private input. Thus, the verifier can play the role of circuit garbler.